using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Cudafy;
using Cudafy.Host;
using Cudafy.Translator;
using Cudafy.Types;

using System.Drawing;
using System.Drawing.Imaging;
using System.Numerics;
 



namespace Aldyparen
{
    class CudaPainter
    {
         

        private static GPGPU gpu;
        public static bool enabled = false;
        public static bool corrupted = false;
 
        public static String errorMessage;

        public static bool cudaEnable()
        {
            try
            {
                CudafyModule km = CudafyTranslator.Cudafy();
                Console.WriteLine("Translator OK");
                gpu = CudafyHost.GetDevice(CudafyModes.Target, CudafyModes.DeviceId);
                Console.WriteLine("GPU OK");
                gpu.LoadModule(km);
                enabled = true;
                return true;
            }
            catch (Exception ex)
            {
                errorMessage = ex.ToString();
                return false; 
            } 
        }

        public static void cudaDisable()
        {
            enabled = false;
        }

        public static bool isCudaAvailable()
        {
            return (getProperties() != null);
        }

        public static GPGPUProperties getProperties()
        { 
            foreach (GPGPUProperties prop in CudafyHost.GetDeviceProperties(CudafyModes.Target))
            {
                return prop;
            }
            return null;
        }

        public static String getPropertiesString()
        {
            GPGPUProperties prop = getProperties();
            if(prop==null) return "N/A";

            StringBuilder sb = new StringBuilder();
            sb.AppendFormat("   --- General Information for device {0} ---\n", 0);
            sb.AppendFormat("Name:  {0}\n", prop.Name);
            sb.AppendFormat("Platform Name:  {0}\n", prop.PlatformName);
            sb.AppendFormat("Device Id:  {0}\n", prop.DeviceId);
            sb.AppendFormat("Compute capability:  {0}.{1}\n", prop.Capability.Major, prop.Capability.Minor);
            sb.AppendFormat("Clock rate: {0}\n", prop.ClockRate);
            sb.AppendFormat("Simulated: {0}\n", prop.IsSimulated);
            sb.AppendFormat("\n");

            sb.AppendFormat("   --- Memory Information for device {0} ---\n", 0);
            sb.AppendFormat("Total global mem:  {0}\n", prop.TotalMemory);
            sb.AppendFormat("Total constant Mem:  {0}\n", prop.TotalConstantMemory);
            sb.AppendFormat("Max mem pitch:  {0}\n", prop.MemoryPitch);
            sb.AppendFormat("Texture Alignment:  {0}\n", prop.TextureAlignment);
            sb.AppendFormat("\n");

            sb.AppendFormat("   --- MP Information for device {0} ---", 0);
            sb.AppendFormat("Shared mem per mp: {0}\n", prop.SharedMemoryPerBlock);
            sb.AppendFormat("Registers per mp:  {0}\n", prop.RegistersPerBlock);
            sb.AppendFormat("Threads in warp:  {0}\n", prop.WarpSize);
            sb.AppendFormat("Max threads per block:  {0}\n", prop.MaxThreadsPerBlock);
            sb.AppendFormat("Max thread dimensions:  ({0}, {1}, {2})", prop.MaxThreadsSize.x,
                              prop.MaxThreadsSize.y, prop.MaxThreadsSize.z);
            sb.AppendFormat("Max grid dimensions:  ({0}, {1}, {2})", prop.MaxGridSize.x, prop.MaxGridSize.y,
                              prop.MaxGridSize.z);

            return sb.ToString();
        }

        public static bool canRender(Frame frame)
        {
            return (frame.genMode==Frame.GeneratingMode.Formula);
        }

        unsafe public static Bitmap render(int W, int H, Frame frame)
        {
            if (frame.genMode != Frame.GeneratingMode.Formula)
            {
                throw new Exception("Cannot render frame with CUDA. Frame generated by formla needed.");
            }

            if (corrupted)
            {
                throw new Exception("You must to restart application id you want to use CUDA!");
            }

            try
            {
                if (!gpu.IsCurrentContext)
                {
                    gpu.SetCurrentContext();
                }


                byte[] b = new byte[12 * W * H];



                //Allocating memory for answer
                byte[] dev_b = gpu.Allocate<byte>(12 * W * H);
                gpu.CopyToDevice(b, dev_b);




                //Forming and passing color map
                int colorCount = frame.colorMap.Length;
                byte[] colorMap = new byte[3 * colorCount];
                byte[] dev_colorMap = gpu.Allocate<byte>(3 * colorCount);
                for (int i = 0; i < colorCount; i++)
                {
                    colorMap[3 * i] = frame.colorMap[i].B;
                    colorMap[3 * i + 1] = frame.colorMap[i].G;
                    colorMap[3 * i + 2] = frame.colorMap[i].R;
                }
                gpu.CopyToDevice(colorMap, dev_colorMap);



                //Forming and passing RPN for frame's formula
                byte[] dev_rpnFormula = gpu.Allocate<byte>(frame.param.genFunc.rpnFormula.Length);
                gpu.CopyToDevice(frame.param.genFunc.rpnFormula, dev_rpnFormula);

                int cnt = frame.param.genFunc.rpnKoef.Length;
                ComplexF[] rpnKoef = new ComplexF[cnt];
                for (int i = 0; i < cnt; i++)
                {
                    rpnKoef[i] = makeComplexFFromNet(frame.param.genFunc.rpnKoef[i]);
                }

                if (cnt == 0)
                {
                    cnt = 1;
                    rpnKoef = new ComplexF[1] { new ComplexF(0, 0) };
                }

                ComplexF[] dev_rpnKoef = gpu.Allocate<ComplexF>(cnt);

                gpu.CopyToDevice(rpnKoef, dev_rpnKoef);




                //Allocating memory for stacks
                ComplexF[] dev_stackMem = gpu.Allocate<ComplexF>(4 * W * H * Function.MAX_STACK_SIZE);


                 
                //Calling main routine
                dim3 gs = new dim3(2 * W, 2 * H);
                int N = frame.param.genFunc.rpnFormula.Length;
                gpu.Launch(gs, 1).setPixelFuck(W, H, N, dev_b, dev_colorMap, dev_stackMem, dev_rpnFormula, dev_rpnKoef, (float)frame.rotation, (float)frame.scale, new ComplexF((float)frame.ctr.Real, (float)frame.ctr.Imaginary), new ComplexF((float)frame.param.genInit.Real, (float)frame.param.genInit.Imaginary), (float)frame.param.genInfty,frame.param.genSteps);

                gpu.CopyFromDevice(dev_b, b);



                //Freeing memory
                gpu.Free(dev_b);
                gpu.Free(dev_colorMap);
                gpu.Free(dev_rpnFormula);
                gpu.Free(dev_rpnKoef);
                gpu.Free(dev_stackMem);



                int W2 = W * 2;
                int H2 = H * 2;
                Bitmap bmp = new Bitmap(W2, H2, PixelFormat.Format24bppRgb);
                BitmapData bd = bmp.LockBits(new Rectangle(0, 0, W2, H2), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
                byte* curpos = ((byte*)bd.Scan0);


                for (int y = 0; y < H2; y++)
                {
                    curpos = ((byte*)bd.Scan0) + y * bd.Stride;
                    int offset = y * 3 * W2;
                    for (int x = 0; x < 3 * W2; x++)
                    {
                        *(curpos++) = b[x + offset];
                    }
                }


                bmp.UnlockBits(bd);
                return bmp;
            }
            catch (Exception ex)
            {
                corrupted = true;
                return null;
            }      
          

            
        }
       


        [Cudafy]
        private static int Mandelbrot(ComplexF c)
        {
            //DEBUG = MANDELBROT
            float r = Cudafy.GMath.Sqrt((c.x - 0.25F) * (c.x - 0.25F) + c.y * c.y);
            float t = Cudafy.GMath.Atan2(c.y, c.x);
            if (r <= 0.5 * (1 - Cudafy.GMath.Cos(t))) return 0;
             

            ComplexF z = new ComplexF(0,0);
            for (int i = 0; i < 200; i++)
            {
                z = ComplexF.Add(ComplexF.Multiply( z ,z), c);
                if (z.x * z.x + z.y * z.y > 4) return 1;
            }
            return 0;
        }


        [Cudafy]
        private static void setPixelFuck(GThread thread, int W, int H, int rpnLength,byte[] bmp, byte[] colorMap,ComplexF[] stackMem, byte[] rpnFormula, ComplexF[] rpnKoef ,float rotation, float scale, ComplexF ctr,ComplexF init,float infty,int steps )
        {
            int x = thread.blockIdx.x;
            int y = thread.blockIdx.y;
            int idx = x + 2 * W * y; 
             
            ComplexF c1 = new ComplexF(Cudafy.GMath.Cos( rotation), Cudafy.GMath.Sin( rotation)); 
            ComplexF c2 = new ComplexF((x - W) * (scale / W), (y - H) * (scale / W)) ;
            ComplexF c = ComplexF.Add(  ComplexF.Multiply(c1,c2), ctr);


            int clr = getSequenceDivergence(c, rpnLength, rpnFormula, rpnKoef, init, infty, steps, stackMem, Function.MAX_STACK_SIZE * idx); 
             


            bmp[3 * idx] = colorMap[3 * clr];
            bmp[3 * idx + 1] = colorMap[3 * clr+1];
            bmp[3 * idx + 2] = colorMap[3 * clr+2];      
        }
        /*
        [Cudafy]
        private static void setPixel(GThread thread, int W, int H, 
            float rotation, float scale, ComplexF ctr, ComplexF init, float infty, int steps,
            byte[] bmp, byte[] colorMap,
            int rpnLength, byte[] rpnFormula, ComplexF[] rpnKoef,ComplexF[] stackMem)
        { 
            
            //int clr =   getSequenceDivergence(c, rpnLength, rpnFormula, rpnKoef, init, infty, steps, stackMem, Function.MAX_STACK_SIZE * idx); 
             
            
        }*/



        private static ComplexF makeComplexFFromNet(Complex x)
        {
            return new ComplexF((float)x.Real, (float)x.Imaginary);
        }

         
        [Cudafy]
        private static int getSequenceDivergence(ComplexF c, int rpnLength, byte[] rpnFormula, ComplexF[] rpnKoef,
            ComplexF init, float infty, int steps, ComplexF[] stackMem, int stackOffset)
        { 
            ComplexF z = init; 
            for (int i = steps - 1; i >= 1; i--)
            { 
                z = eval(rpnLength, rpnFormula, rpnKoef, c, z, stackMem, stackOffset);
                if (abs(z) > infty) return i;
            }
            return 0;
        }



        #region "Math"

        


        [Cudafy]
        private static float abs(ComplexF c)
        {
            return Cudafy.GMath.Sqrt(c.x * c.x + c.y * c.y);
        }

        [Cudafy]
        private static float arg(ComplexF c)
        {
            return Cudafy.GMath.Atan2(c.y, c.x);
        }

        [Cudafy]
        private static ComplexF makeComplexF(float _abs, float _arg)
        {
            return new ComplexF(_abs * Cudafy.GMath.Cos(_arg), _abs * Cudafy.GMath.Sin(_arg));
        }

        [Cudafy]
        private static ComplexF eIPhi(float phi)
        {
            return new ComplexF(Cudafy.GMath.Cos(phi), Cudafy.GMath.Sin(phi));
        }

        [Cudafy]
        private static ComplexF exp(ComplexF c)
        {
            return makeComplexF(Cudafy.GMath.Exp(c.x), c.y);
        }


        [Cudafy]
        private static ComplexF log(ComplexF c)
        {
            return new ComplexF(Cudafy.GMath.Log(abs(c)), arg(c));
        }

        [Cudafy]
        private static ComplexF sin(ComplexF c)
        {
            ComplexF ic = new ComplexF(-c.x, c.y);       //ic
            ComplexF mic = new ComplexF(c.x, -c.y);     //-c

            ComplexF t = ComplexF.Subtract(exp(ic), exp(mic));
            return new ComplexF(t.x / 2, t.y / 2);
        }

        [Cudafy]
        private static ComplexF cos(ComplexF c)
        {
            ComplexF ic = new ComplexF(-c.x, c.y);       //ic
            ComplexF mic = new ComplexF(c.x, -c.y);     //-c

            ComplexF t = ComplexF.Add(exp(ic), exp(mic));
            return new ComplexF(t.x / 2, t.y / 2);
        }

        [Cudafy]
        private static ComplexF tg(ComplexF c)
        {
            ComplexF sn = sin(c);
            ComplexF cs = cos(c);

            if (cs.x == 0 && cs.y == 0) return new ComplexF(1e37F, 0);
            return ComplexF.Divide(sn, cs);
        }

        [Cudafy]
        private static ComplexF ctg(ComplexF c)
        {
            ComplexF sn = sin(c);
            ComplexF cs = cos(c);

            if (sn.x == 0 && sn.y == 0) return new ComplexF(1e37F, 0);
            return ComplexF.Divide(cs, sn);
        }

        [Cudafy]
        private static ComplexF th(ComplexF c)
        {
            ComplexF sn = sh(c);
            ComplexF cs = ch(c);

            if (cs.x == 0 && cs.y == 0) return new ComplexF(1e37F, 0);
            return ComplexF.Divide(sn, cs);
        }

        [Cudafy]
        private static ComplexF cth(ComplexF c)
        {
            ComplexF sn = sh(c);
            ComplexF cs = ch(c);

            if (sn.x == 0 && sn.y == 0) return new ComplexF(1e37F, 0);
            return ComplexF.Divide(cs, sn);
        }

        [Cudafy]
        private static ComplexF sqrt(ComplexF c)
        {
            return makeComplexF(Cudafy.GMath.Sqrt(abs(c)), arg(c) / 2);
        }

        [Cudafy]
        private static ComplexF sh(ComplexF c)
        {
            ComplexF t = ComplexF.Subtract(exp(c), exp(new ComplexF(-c.x, -c.y)));
            return new ComplexF(t.x / 2, t.y / 2);
        }

        [Cudafy]
        private static ComplexF ch(ComplexF c)
        {
            ComplexF t = ComplexF.Add(exp(c), exp(new ComplexF(-c.x, -c.y)));
            return new ComplexF(t.x / 2, t.y / 2);
        }

        [Cudafy]
        private static ComplexF pow(ComplexF c1, ComplexF c2)
        {
            float a = abs(c1);
            float b = arg(c1);
            float c =   c2.x;
            float d =   c2.y;

            if (a == 0) a = 1e-38F;

            return makeComplexF(Cudafy.GMath.Pow(a, c) * Cudafy.GMath.Exp(-b * d), Cudafy.GMath.Log(a) * d + b * c);
             
        }


        [Cudafy]
        private static ComplexF arcsin(ComplexF c)
        {
            ComplexF x1 = new ComplexF(-c.y, c.x);
            ComplexF one = new ComplexF(1, 0);
            ComplexF x2 = sqrt(ComplexF.Subtract(one, ComplexF.Multiply(c, c)));

            ComplexF minusImagOne = new ComplexF(0, -1);
            return ComplexF.Multiply(minusImagOne, log(ComplexF.Add(x1, x2)));
        }

        [Cudafy]
        private static ComplexF arccos(ComplexF c)
        {
            ComplexF one = new ComplexF(1, 0);
            ComplexF x2 = sqrt(ComplexF.Subtract(ComplexF.Multiply(c, c), one));

            ComplexF minusImagOne = new ComplexF(0, -1);
            return ComplexF.Multiply(minusImagOne, log(ComplexF.Add(c, x2)));
        }

        [Cudafy]
        private static ComplexF arctg(ComplexF c)
        {
            ComplexF one = new ComplexF(1, 0);
            return one;
        }

        [Cudafy]
        private static ComplexF arcctg(ComplexF c)
        {
            ComplexF one = new ComplexF(1, 0);
            return one;
        }


        [Cudafy]
        private static ComplexF eval(int rpnLength, byte[] rpnFormula, ComplexF[] rpnKoef, ComplexF c, ComplexF z, ComplexF[] stack, int stackOffset)
        {
            //return ComplexF.Add( ComplexF.Multiply(ComplexF.Multiply(z,z),z),c);


            int sPtr = stackOffset - 1;
            int vPtr = 0;

            for (int i = 0; i < rpnLength; i++)
            {
                byte v = rpnFormula[i];
                if (v == 0)
                {
                    stack[++sPtr] = rpnKoef[vPtr++];
                }
                else if (v <= 5)
                {
                    if (v == 1) stack[sPtr - 1] = ComplexF.Add(stack[sPtr - 1], stack[sPtr]);
                    else if (v == 2) stack[sPtr - 1] = ComplexF.Subtract(stack[sPtr - 1], stack[sPtr]);
                    else if (v == 3) stack[sPtr - 1] = ComplexF.Multiply(stack[sPtr - 1], stack[sPtr]);
                    else if (v == 4) stack[sPtr - 1] = ComplexF.Divide(stack[sPtr - 1], stack[sPtr]);
                    else if (v == 5) stack[sPtr - 1] = pow(stack[sPtr - 1], stack[sPtr]);

                    sPtr--;
                }
                else if (v <= 10)
                {
                    if (v == 6) stack[sPtr] = log(stack[sPtr]);
                    else if (v == 7) stack[sPtr] = exp(stack[sPtr]);
                    else if (v == 8) stack[sPtr] = sin(stack[sPtr]);
                    else if (v == 9) stack[sPtr] = cos(stack[sPtr]);
                    else if (v == 10) stack[sPtr] = tg(stack[sPtr]);
                }
                else if (v <= 19)
                {
                    if (v == 11) stack[sPtr] = ctg(stack[sPtr]);
                    else if (v == 12) stack[sPtr] = arcsin(stack[sPtr]);
                    else if (v == 13) stack[sPtr] = arccos(stack[sPtr]);
                    else if (v == 14) stack[sPtr] = arctg(stack[sPtr]);
                    else if (v == 15) stack[sPtr] = arcctg(stack[sPtr]);
                    else if (v == 16) stack[sPtr] = sh(stack[sPtr]);
                    else if (v == 17) stack[sPtr] = ch(stack[sPtr]);
                    else if (v == 18) stack[sPtr] = th(stack[sPtr]);
                    else if (v == 19) stack[sPtr] = cth(stack[sPtr]);
                }
                else if (v <= 25)
                {
                    if (v == 20) stack[sPtr] = new ComplexF(abs(stack[sPtr]), 0);
                    if (v == 21) stack[sPtr] = new ComplexF(stack[sPtr].x, 0);
                    if (v == 22) stack[sPtr] = new ComplexF(stack[sPtr].y, 0);
                    if (v == 23) stack[sPtr] = new ComplexF(arg(stack[sPtr]), 0);
                    if (v == 24) stack[sPtr] = sqrt(stack[sPtr]);
                    if (v == 25) stack[sPtr] = new ComplexF(-stack[sPtr].x, -stack[sPtr].y);
                }
                else if (v == 64) stack[++sPtr] = c;
                else if (v == 65) stack[++sPtr] = z;
            }

            return stack[stackOffset];
        }


        #endregion
       


    }
}
